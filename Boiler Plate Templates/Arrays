//rotate an array to left/right by k places
leftRotate(int [] nums,int k){
  int n = nums.length;
  k = k % n;
  reverse(nums,0,k-1);
  reverse(nums,k,n-1);
  reverse(nums,0,n-1);
}

rightRotate(int [] nums,int k){
  int n = nums.length;
  int k = k % n;
  reverse(nums,0,n-1);
  reverse(nums,0,k-1);
  reverse(nums,k,n-1);
}

reverse(int [] nums,int low,int high){    //reverse using two pointer approach
  while(low<high){
  int temp = nums[low];
  nums[low] = nums[high];
  nums[high]=temp;
  low++;
  high--;
  }
}

//reverse using indexing

k=k%n;
for(int i=0;i<n;i++){
  rotated[(i+k)%n]=nums[i];//right rotate by k places
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Move zeroes to end of array
over write non zero elements over the left of array
function(int [] nums){
  int i=0;
  int n = nums.length;
  for(int j=0;j<n;j++){
    if(nums[j]!=0){
      nums[i++]=nums[j];
    }
  }
  while(i<n) nums[i]=0;
}
input nums=[1,2,3,0,0,4,7,6]
outpt nums=[1,2,3,4,7,6,0,0]
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
//next permutation of array

class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        if(n==1) return;
        int index=n-1;          //break point
        for(index=n-2;index>=0;index--){
            if(!(nums[index]>=nums[index+1])){
                break;
            }
        }


        if(index==-1) {         //last permutation [3,2,1]
            reverse(nums,0,n-1);        //[1,2,3]
            return;
        }

        int next=0;
        for(next=n-1 ;next>index ;next--){
            if(nums[next] > nums[index]) break;
        }
        int temp = nums[index];
        nums[index]=nums[next];
        nums[next]=temp;
        reverse(nums,index+1,n-1);
    }
    public static void reverse(int [] nums,int low,int high){
        while(low<=high){
            int temp = nums[low];
            nums[low]= nums[high];
            nums[high]=temp;
            low++;
            high--;
        }
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Leetcode 3583 - Prefix Suffix Count ( middle, left, right)
class Solution {
    public static int MOD=1000000007;
    public int specialTriplets(int[] nums) {
        int n = nums.length;
        Map <Integer,Integer> freqPrev = new HashMap<>();
        Map <Integer,Integer> freqNext = new HashMap<>();
        for(int i=0;i<n;i++){
            freqNext.put(nums[i],freqNext.getOrDefault(nums[i],0)+1);
        }
        int ans=0;
        for(int j=0;j<n;j++){
            freqNext.put(nums[j],freqNext.get(nums[j])-1);
                int outlier = nums[j]*2;
                int left =freqPrev.getOrDefault(outlier,0);
                int right=freqNext.getOrDefault(outlier,0);
                long product = (long) left * right;
                ans = (int) ((ans+product)%MOD);
            freqPrev.put(nums[j],freqPrev.getOrDefault(nums[j],0)+1);
        }
        return ans;
    }
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
subarray sum equals k - prefix sum (count how many sub array has with target sum)
class Solution {
    public int subarraySum(int[] nums, int k) {
        int sum = 0,ans=0;
        Map <Integer,Integer> mpp = new HashMap<>();  //prefix sum, count
        mpp.put(0,1);    
        for(int i=0;i<nums.length;i++){
            sum+= nums[i];
            ans = ans + mpp.getOrDefault(sum-k,0);
            mpp.put(sum,mpp.getOrDefault(sum,0)+1);
        }
        return ans;
    }
}
nums[i] E [-1000,+1000]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
print pascals triangle
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans =new ArrayList<>();
        for(int i=0;i<numRows;i++){
            List <Integer> row = genRow(i);
            ans.add(row);
        }
        return ans;
    }
    public static List<Integer> genRow(int n){
        List<Integer> row = new ArrayList<>();
        long prev=1;
        row.add(1); //nc0'
        for(int r=1;r<=n;r++){
            prev = prev * (n-r+1)/r;
            row.add((int)prev);
        }
        return row;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
