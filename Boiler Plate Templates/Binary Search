First and Last Occurence of target in sorted array
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length;
        int lbnd= -1;
        int low = 0,high = n-1;
        while(low<=high){
            int mid = low + (high - low)/2;
            if(nums[mid]>=target){
                lbnd = mid;
                high = mid -1;
            }
            else low = mid + 1;
        }

        low =0;
        high = n-1;
        int ubnd = -1;
        while(low<=high){
            int mid = low + (high - low)/2;
            if(nums[mid]>target){
                ubnd = mid;
                high = mid - 1;
            }
            else low = mid + 1;
        }
        
        if(lbnd==ubnd) return new int[]{-1,-1};
        if(ubnd==-1) return new int []{lbnd,n-1};
        return new int[]{lbnd,ubnd-1};

    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
search in rotated sorted array - distinct elements
class Solution {
    
    public int search(int[] nums, int target) {
        int n= nums.length;
        int low = 0,high=n-1;
        while(low<=high){
            
            int mid = low + (high-low)/2;
            if(nums[mid]==target) return mid;

            if(nums[low]<=nums[mid]){
                if(target>=nums[low] && target<nums[mid]){
                        high = mid-1;
                }
                else{
                        low = mid+1;
                }
            }
            else{
                if(target<=nums[high] && target>nums[mid]){
                    low = mid + 1;
                }   
                else{
                    high = mid-1;
                }
            }
        }
        return -1;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------
Koko Eating Banana - Linear Search or Binary Search of Answer.
class Solution {
    //linear search O(N * MaxPile)
    public int minEatingSpeed(int[] piles, int h) {
        int max = 0;
        for(int x:piles) max = Math.max(max,x);
        for(int i=1;i<=max;i++){
            if(noOfHours(piles,i)<=h) return i;
        }
        return -1;
    }
    //Binary Search O(N * Log(MaxPile))
    public int minEatingSpeed(int[] piles, int h) {
        int max = 0;
        for(int x:piles) max = Math.max(max,x);

        int ans=0;
        int low=1,high=max;
        while(low<=high){
            int mid = low + (high-low)/2;
            if(noOfHours(piles,mid)<=h){ans=mid; high=mid-1;}
            else low = mid + 1;
        }
        return ans;
    }
    //integer overflow in calculating hours -- use long, 
    public static long noOfHours(int[]piles,int i){
        long hours=0;
        for(int x:piles){
            hours = hours + (x+i-1)/i;        //ceil division
        }
        return hours;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Minimum number of days to make m bouquets
class Solution {
    //)(MaxBloom * N) - linear search
    public int minDays(int[] bloomDay, int m, int k) {
        int n = bloomDay.length;
        if(n<(long)m*k) return -1;
        int max=0;
        for(int x:bloomDay) max = Math.max(max,x);
        for(int i=1;i<=max;i++){
            if(function(i,bloomDay,k,m)) return i;
        }
        return -1;
    }
    //O(logMaxBloom * N) - binary search
    public int minDays(int[] bloomDay, int m, int k) {
        int n = bloomDay.length;
        if(n<(long)m*k) return -1;
        int max=0;
        for(int x:bloomDay) max = Math.max(max,x);
        int low=1,high=max;
        int ans=0;
        while(low<=high){
            int mid = low + (high-low)/2;
            if(function(mid,bloomDay,k,m)){
                ans=mid;
                high=mid-1;
            } else low = mid +1;
        }
        return ans;
    }
    public static boolean function(int i, int [] bloomDay,int k,int m){
        int n = bloomDay.length;
        int cnt=0,bookie=0;
        for(int j=0;j<n;j++){
            if(bloomDay[j]<=i){
                cnt++;
                if(cnt==k){
                    bookie++;
                    cnt=0;
                    if(bookie==m) return true;
                }
            }
            else cnt=0;
        }
        return false;
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Min Capacity of Truck to ship Packages within D Days
class Solution {
    //O((SumWeights-MaxWeights) * N) - linear search
     public int shipWithinDays(int[] weights, int days) {
        int max=0,sum=0;
        for(int x:weights){
            max = Math.max(max,x);
            sum = sum + x;
        }

        for(int cap = max;cap<=sum;cap++){
            if(function(cap,weights,days)){
                return cap;
            }
        }
        return -1;
    }
    //O(log(SumWeights-MaxWeights) * N) - binary search
    public int shipWithinDays(int[] weights, int days) {
        int max=0,sum=0;
        for(int x:weights){
            max = Math.max(max,x);
            sum = sum + x;
        }

        int low=max,high=sum;
        int ans=0;
        while(low<=high){
            int mid = low + (high-low)/2;
            if(function(mid,weights,days)){
                ans=mid;
                high=mid-1;
            }
            else low = mid + 1;
        }
        return ans;
    }
    public static boolean function(int cap,int[] weights,int days){
        int load =0,cnt=1;        //count days from first day
        for(int x:weights){
            if(load + x <=cap) load = load  + x;
            else{
                cnt=cnt+1;
                load=x;
            }
        }
        return (cnt<=days);
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
class Solution {
//linear search on solution
    public int aggressiveCows(int[] stalls, int k) {
        Arrays.sort(stalls);
        int n = stalls.length;
        int min=Integer.MAX_VALUE;
        int max = stalls[n-1]-stalls[0];
        for(int i=1;i<stalls.length;i++) min = Math.min(stalls[i]-stalls[i-1],min);
        for(int dis=max;dis>=min;dis--){
            if(function(dis,stalls,k)){
                return dis;
            }
        }
        return -1;
    }
//binary search on solution
public int aggressiveCows(int[] stalls, int k) {
        Arrays.sort(stalls);
        int n = stalls.length;
        int min=Integer.MAX_VALUE;
        int max = stalls[n-1]-stalls[0];
        for(int i=1;i<stalls.length;i++) min = Math.min(stalls[i]-stalls[i-1],min);
        int low=min,high=max;
        int ans=0;
        while(low<=high){
            int mid = low + (high-low)/2;
            if(function(mid,stalls,k)){
                ans=mid;
                low = mid + 1;
            }
            else high=mid-1;
        }
        return ans;
    }
    public static boolean function(int dis,int[] stalls,int k){
        int n  = stalls.length;
        int lastCow=stalls[0];
        int cnt=1;
        for(int i=0;i<n;i++){
            if(stalls[i]-lastCow>=dis){
                cnt++;
                lastCow=stalls[i];
            }
        }
        return cnt>=k;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
finding kth positive missing number (i dont know how to convert it to binary search on answers)
class Solution {
    public int findKthPositive(int[] arr, int k) {
        int n = arr.length;
        int low=0,high=n-1;
        int ans=-1;
        while(low<=high){
            int mid = low + (high-low)/2;
            if(arr[mid]-(mid+1)<k){
                ans=mid;
                low=mid+1;
            }
            else high=mid-1;
        }
        return k+ans+1;
    }
}
return expression k+ans+1 is reduced from this
ans[mid] + (k-(ans[mid]-(mid+1)))
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
find smallest divisor (same as koko eating banana)
class Solution {
    public int smallestDivisor(int[] nums, int threshold) {
        int low = 1;
        int max=0;
        for(int x:nums){
            max = Math.max(max,x);
        }
        int high=max;
        int ans=-1;
        while(low<=high){
            int mid = low + (high-low)/2;
            if(function(mid,nums,threshold)){
                ans=mid;
                high=mid-1;
            }else low=mid+1;
        }
        return ans;
    }
    public static boolean function(int mid,int[]nums,int thre){
        long sum=0;
        for(int x:nums){
            sum = sum + (x+mid-1)/mid;
        }
        return sum<=thre;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
