Fibonacci series

recursive
f(n){
  if(n<=1) return n;
  return f(n-1) + f(n-2);
}

memoization
int [] dp = new int[n+1];
for(int i=0;i<=n;i++) dp[i]=-1;
f(5,dp);

f(n,dp){
  if(dp[n]!=-1) return dp[n];
  if(n<=1) return dp[n]=n;
  return dp[n] = f(n-1,dp) + f(n-2,dp);
}

tabulation
int [] dp = new int[n+1];
dp[0]=0;
dp[1]=1;
for(int i=2;i<=n;i++) dp[i]=dp[i-1] + dp[i-2];
return dp[n];

space optimization
int prev2=0,prev=1;
for(int i=2;i<=n;i++){
  int curi = prev + prev2;
  prev2 = prev;
  prev = curi;
}
return prev;

------------------------------------------------------------------------------------------------------------------------------------------------------------
Count total number of ways to solve a problem
f(N){
  if(N==0) return +1;
  int left = f(N-1);
  int right = f(N-2);
  return left + right;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
tabulation to space optimization 1D DP

tabulation

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int [] dp = new int[n];
        for(int i=0;i<n;i++){
            if(i==0) dp[i]=nums[i];
            else if(i==1) dp[i] = Math.max(nums[0],nums[1]);
            //rob or not rob
            else dp[i]=Math.max(nums[i]+dp[i-2],dp[i-1]);
        }
        return dp[n-1];
    }
}

space optimization

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int prev=0,prev2=0;
        for(int i=0;i<n;i++){
            int curr=Math.max(nums[i]+prev2,prev);
            prev2=prev;
            prev=curr;
        }
        return prev;
    }
}

