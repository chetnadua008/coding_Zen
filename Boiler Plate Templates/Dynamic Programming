Fibonacci series

recursive
f(n){
  if(n<=1) return n;
  return f(n-1) + f(n-2);
}

memoization
int [] dp = new int[n+1];
for(int i=0;i<=n;i++) dp[i]=-1;
f(5,dp);

f(n,dp){
  if(dp[n]!=-1) return dp[n];
  if(n<=1) return dp[n]=n;
  return dp[n] = f(n-1,dp) + f(n-2,dp);
}

tabulation
int [] dp = new int[n+1];
dp[0]=0;
dp[1]=1;
for(int i=2;i<=n;i++) dp[i]=dp[i-1] + dp[i-2];
return dp[n];

space optimization
int prev2=0,prev=1;
for(int i=2;i<=n;i++){
  int curi = prev + prev2;
  prev2 = prev;
  prev = curi;
}
return prev;

------------------------------------------------------------------------------------------------------------------------------------------------------------
Count total number of ways to solve a problem
f(N){
  if(N==0) return +1;
  int left = f(N-1);
  int right = f(N-2);
  return left + right;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
tabulation to space optimization 1D DP

tabulation

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int [] dp = new int[n];
        for(int i=0;i<n;i++){
            if(i==0) dp[i]=nums[i];
            else if(i==1) dp[i] = Math.max(nums[0],nums[1]);
            //rob or not rob
            else dp[i]=Math.max(nums[i]+dp[i-2],dp[i-1]);
        }
        return dp[n-1];
    }
}

space optimization

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int prev=0,prev2=0;
        for(int i=0;i<n;i++){
            int curr=Math.max(nums[i]+prev2,prev);
            prev2=prev;
            prev=curr;
        }
        return prev;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2D Dynamic Programming - Ninja Training Problem / Paint House Problem
function(day,last){          ..returns maximum points from 0th day to day
  ..base case
  if(day==0){
    int maxi = 0;
    for(int i=0;i<3;i++){
      if(i!=last){
        maxi = maxx(maxi,task[0][i]);
      }
    }
    return maxi;
  }
  ..normal day
  maxPoints = 0;
  for(int i=0;i<3;i++){
    if(i!=last){
      points = task[day][i] + function(day-1,i);
      maxPoints = max(maxPoints,points);
    }
  }
  return maxPoints;
}

call for function(N-1,3)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Unique Paths in a grid

recursive -> M-1,N-1 to 0,0 cell

function(int i,int j,int m,int n){
  if(i==m-1 && j==n-1) return +1;
  if(i<0 || j<0) return 0;
  int up = function(i-1,j,m,n)
  int down = function(i,j-1,m,n)
  return up + down;
}

function(m-1,n-1,m,n)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Unique paths + obstacle constraint
tabulated method

class Solution {
    public int uniquePathsWithObstacles(int[][] obs) {
        if(obs[0][0]==1) return 0;
        int m = obs.length,n = obs[0].length;
        int [][] dp = new int[m][n];//tabulation table
        dp[0][0]=1;//base case
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){       //iterate
                if(i==0 && j==0) continue;
                if(obs[i][j]==1) dp[i][j]=0;        //obstacle case
                else{
                    int up = 0,left = 0;        //default up and left
                    if(i>0) up = dp[i-1][j];
                    if(j>0) left = dp[i][j-1];  //function call replaced with dp
                    dp[i][j]=up + left;
                }

            }
        }
        return dp[m-1][n-1];
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Min Cost Path in Grid - 2D DP (Fix start and Fix target)
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[] prev = new int[n];

        for(int i=0; i<m; i++) {
            // Create current row array
            int[] curr = new int[n]; 
            
            for(int j=0; j<n; j++) {
                if(i==0 && j==0) {
                    curr[j] = grid[i][j]; // Base Case: Start
                }
                else {
                    int up = Integer.MAX_VALUE;
                    int left = Integer.MAX_VALUE;
                    
                    // Look Up (Access 'prev' array)
                    if(i > 0) up = prev[j];
                    
                    // Look Left (Access 'curr' array)
                    if(j > 0) left = curr[j-1];
                    
                    curr[j] = grid[i][j] + Math.min(up, left);
                }
            }
            // Move Current row to Previous row for next iteration
            prev = curr;
        }
        
        return prev[n-1];
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Triangular Grid (Fixed start to variable target cell last row) min cost path
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int [] prev = new int[n];
        for(int i=0;i<n;i++) prev[i]=triangle.get(n-1).get(i);
        for(int i=n-2;i>=0;i--){
            int [] curr = new int[n];
            for(int j=i;j>=0;j--){
                curr[j] = triangle.get(i).get(j) + Math.min(prev[j],prev[j+1]);
            }
            prev=curr;
        }
        return prev[0];
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
falling path sum
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int minCost = Integer.MAX_VALUE;
        int n = matrix.length;
        int [] prev = new int[n];
        for(int i=0;i<n;i++) prev[i] = matrix[0][i];

        for(int i=1;i<n;i++){
            int [] curr = new int[n];
            for(int j=0;j<n;j++){
                curr[j] = matrix[i][j];
                int left = (j>0)?prev[j-1]:Integer.MAX_VALUE;
                int up = prev[j];
                int right = (j<n-1)?prev[j+1]:Integer.MAX_VALUE;
                curr[j] += Math.min(left,Math.min(right,up));
            }
            prev=curr;
        }

        for(int x:prev){
            minCost = Math.min(x,minCost);
        }
        return minCost;
        
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
