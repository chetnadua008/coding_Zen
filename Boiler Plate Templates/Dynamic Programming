Fibonacci series

recursive
f(n){
  if(n<=1) return n;
  return f(n-1) + f(n-2);
}

memoization
int [] dp = new int[n+1];
for(int i=0;i<=n;i++) dp[i]=-1;
f(5,dp);

f(n,dp){
  if(dp[n]!=-1) return dp[n];
  if(n<=1) return dp[n]=n;
  return dp[n] = f(n-1,dp) + f(n-2,dp);
}

tabulation
int [] dp = new int[n+1];
dp[0]=0;
dp[1]=1;
for(int i=2;i<=n;i++) dp[i]=dp[i-1] + dp[i-2];
return dp[n];

space optimization
int prev2=0,prev=1;
for(int i=2;i<=n;i++){
  int curi = prev + prev2;
  prev2 = prev;
  prev = curi;
}
return prev;

------------------------------------------------------------------------------------------------------------------------------------------------------------
Count total number of ways to solve a problem
f(N){
  if(N==0) return +1;
  int left = f(N-1);
  int right = f(N-2);
  return left + right;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
tabulation to space optimization 1D DP

tabulation

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int [] dp = new int[n];
        for(int i=0;i<n;i++){
            if(i==0) dp[i]=nums[i];
            else if(i==1) dp[i] = Math.max(nums[0],nums[1]);
            //rob or not rob
            else dp[i]=Math.max(nums[i]+dp[i-2],dp[i-1]);
        }
        return dp[n-1];
    }
}

space optimization

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int prev=0,prev2=0;
        for(int i=0;i<n;i++){
            int curr=Math.max(nums[i]+prev2,prev);
            prev2=prev;
            prev=curr;
        }
        return prev;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2D Dynamic Programming - Ninja Training Problem / Paint House Problem
function(day,last){          ..returns maximum points from 0th day to day
  ..base case
  if(day==0){
    int maxi = 0;
    for(int i=0;i<3;i++){
      if(i!=last){
        maxi = maxx(maxi,task[0][i]);
      }
    }
    return maxi;
  }
  ..normal day
  maxPoints = 0;
  for(int i=0;i<3;i++){
    if(i!=last){
      points = task[day][i] + function(day-1,i);
      maxPoints = max(maxPoints,points);
    }
  }
  return maxPoints;
}

call for function(N-1,3)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Unique Paths in a grid

recursive -> M-1,N-1 to 0,0 cell

function(int i,int j,int m,int n){
  if(i==m-1 && j==n-1) return +1;
  if(i<0 || j<0) return 0;
  int up = function(i-1,j,m,n)
  int down = function(i,j-1,m,n)
  return up + down;
}

function(m-1,n-1,m,n)
