Fibonacci series

recursive
f(n){
  if(n<=1) return n;
  return f(n-1) + f(n-2);
}

memoization
int [] dp = new int[n+1];
for(int i=0;i<=n;i++) dp[i]=-1;
f(5,dp);

f(n,dp){
  if(n<=1) return n;
  if(dp[n]!=-1) return dp[n];
  return dp[n] = f(n-1,dp) + f(n-2,dp);
}

tabulation
int [] dp = new int[n+1];
dp[0]=0;
dp[1]=1;
for(int i=2;i<=n;i++) dp[i]=dp[i-1] + dp[i-2];
return dp[n];

space optimization
int prev2=0,prev=1;
for(int i=2;i<=n;i++){
  int curi = prev + prev2;
  prev2 = prev;
  prev = curi;
}
return prev;

------------------------------------------------------------------------------------------------------------------------------------------------------------
number of ways to reach solution - return +1 at base case
f(N){
  if(N==0) return +1;
  int left = f(N-1);
  int right = f(N-2);
  return left + right;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
tabulation to space optimization 1D DP
tabulation
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int [] dp = new int[n];
        for(int i=0;i<n;i++){
            if(i==0) dp[i]=nums[i];
            else if(i==1) dp[i] = Math.max(nums[0],nums[1]);
            //rob or not rob
            else dp[i]=Math.max(nums[i]+dp[i-2],dp[i-1]);
        }
        return dp[n-1];
    }
}

space optimization
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int prev=0,prev2=0;
        for(int i=0;i<n;i++){
            int curr=Math.max(nums[i]+prev2,prev);
            prev2=prev;
            prev=curr;
        }
        return prev;
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
2D Dynamic Programming - Ninja Training Problem / Paint House Problem
function(day,last){          ..returns maximum points from 0th day to day
  ..base case
  if(day==0){
    int maxi = 0;
    for(int i=0;i<3;i++){
      if(i!=last){
        maxi = maxx(maxi,task[0][i]);
      }
    }
    return maxi;
  }
  ..normal day
  maxPoints = 0;
  for(int i=0;i<3;i++){
    if(i!=last){
      points = task[day][i] + function(day-1,i);
      maxPoints = max(maxPoints,points);
    }
  }
  return maxPoints;
}

call for function(N-1,3)
-> 3 because initially there is no restriction (last day task)
-> N-1 because we need to get maximum points from day 0 to day N-1
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Count Unique Paths in a grid
recursive -> (M-1,N-1) to (0,0) cell
function(int i,int j,int m,int n){
  if(i==0 && j==0) return +1;
  int up = 0, left = 0;
  if(i>0) up = function(i-1,j,m,n)   //handle walls
  if(j>0) left = function(i,j-1,m,n)
  return up + left;
}

function(m-1,n-1,m,n)
m=number of rows
n=number of columns
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Count unique paths + obstacle constraint
tabulation
class Solution {
    public int uniquePathsWithObstacles(int[][] obs) {
        if(obs[0][0]==1) return 0;
        int m = obs.length,n = obs[0].length;
        int [][] dp = new int[m][n];  
        dp[0][0]=1;//base case
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){       
                if(i==0 && j==0) continue;
                if(obs[i][j]==1) dp[i][j]=0;        //obstacle case
                else{
                    int up = 0,left = 0;        //default up and left
                    if(i>0) up = dp[i-1][j];    //handle walls in grid
                    if(j>0) left = dp[i][j-1];  //function call replaced with dp
                    dp[i][j]=up + left;
                }

            }
        }
        return dp[m-1][n-1];
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Min Cost Path in Grid - 2D DP (Fix start and Fix target)
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[] prev = new int[n];

        for(int i=0; i<m; i++) {
            // Create current row array
            int[] curr = new int[n]; 
            
            for(int j=0; j<n; j++) {
                if(i==0 && j==0) {
                    curr[j] = grid[i][j]; // Base Case: Start
                }
                else {
                    int up = Integer.MAX_VALUE;
                    int left = Integer.MAX_VALUE;
                    if(i > 0) up = prev[j];
                    if(j > 0) left = curr[j-1];                    
                    curr[j] = grid[i][j] + Math.min(up, left);
                }
            }
            // Move Current row to Previous row for next iteration
            prev = curr;
        }
        
        return prev[n-1];
    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Triangular Grid (Fixed start to variable target cell last row) min cost path
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int [] prev = new int[n];
        for(int i=0;i<n;i++) prev[i]=triangle.get(n-1).get(i);
        for(int i=n-2;i>=0;i--){
            int [] curr = new int[n];
            for(int j=i;j>=0;j--){
                curr[j] = triangle.get(i).get(j) + Math.min(prev[j],prev[j+1]);
            }
            prev=curr;
        }
        return prev[0];
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
falling path sum
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int minCost = Integer.MAX_VALUE;
        int n = matrix.length;
        int [] prev = new int[n];
        for(int i=0;i<n;i++) prev[i] = matrix[0][i];

        for(int i=1;i<n;i++){
            int [] curr = new int[n];
            for(int j=0;j<n;j++){
                curr[j] = matrix[i][j];
                int left = (j>0)?prev[j-1]:Integer.MAX_VALUE;
                int up = prev[j];
                int right = (j<n-1)?prev[j+1]:Integer.MAX_VALUE;
                curr[j] += Math.min(left,Math.min(right,up));
            }
            prev=curr;
        }

        for(int x:prev){
            minCost = Math.min(x,minCost);
        }
        return minCost;
        
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
DP on Subsequences 
Subsequence Sum equals target (target shrinking)

function(index,target){
  if(target==0){
    return true;
  }
  if(index==0){
    if(target==array[0]) return true;
    else return false;
  }
  boolean take = false;
  if(target>=array[index]) function(index-1,target-array[index]);
  boolean notTake = function(index-1,target);
  return take || notTake;
}

function(N-1,target)
N-1 represent 0 to N-1 elements in array contain a subsequence of sum = target
target = remaining target
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
