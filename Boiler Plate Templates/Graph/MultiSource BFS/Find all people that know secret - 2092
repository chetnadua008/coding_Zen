class Solution {
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        Set<Integer> knowsSecret = new HashSet<>();
        knowsSecret.add(0);
        knowsSecret.add(firstPerson);
        Arrays.sort(meetings,(m1,m2)->m1[2]-m2[2]);
        int m = meetings.length,i=0;
        while(i<m){
            List<int []> meet = new ArrayList<>();
            do{
                meet.add(meetings[i++]);
            }while(i<m && meetings[i][2]==meetings[i-1][2]);

            Map<Integer,List<Integer>> adjLs = new HashMap<>();
            for(int [] mee:meet){
                int p1 = mee[0];
                int p2 = mee[1];
                adjLs.computeIfAbsent(p1,k->new ArrayList<>()).add(p2);
                adjLs.computeIfAbsent(p2,k->new ArrayList<>()).add(p1);
            }

            
            Set<Integer> source = new HashSet<>();      //initial multisource Bfs
            for(int [] mee:meet){
                if(knowsSecret.contains(mee[0])) source.add(mee[0]);
                if(knowsSecret.contains(mee[1])) source.add(mee[1]);
            }
            

            Queue<Integer> q = new LinkedList<>(source);
            Set<Integer> vis = new HashSet<>(source);

            while(!q.isEmpty()){
                int x = q.poll();
                if(adjLs.containsKey(x)){
                    for(int next:adjLs.get(x)){
                        if(!vis.contains(next)){
                            knowsSecret.add(next);
                            vis.add(next);
                            q.add(next);
                        }
                    }
                }
            }

        }
        return new ArrayList<>(knowsSecret);
    }
}
