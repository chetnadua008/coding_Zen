Assign Cookies
function(int [] greed, int [] cookieSize){  //return maximum number of children that gets one cookie
  Arrays.sort(greed);
  Arrays.sort(cookieSize);
  //goal - dont waste big cookie on a child with small greed
  int i=0,j=0;
  while(i<greed.length && j<cookieSize.length){
    if(greed[i]<=cookieSize[j]){
      i++;
      j++;   //give cookie to the child
    }
    else j++;    //waste cookie
  }
  return i;
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Fractional KnapSack

//combine value,weight and ration in single object
class Item{
    int value,weight;
    double ratio;
    
    public Item(int value,int weight){
        this.value = value;
        this.weight = weight;
        this.ratio = (double)value/(double)weight;
    }
}

class Solution {
    public double fractionalKnapsack(int[] val, int[] wt, int capacity) {
        int N= val.length;
        
        Item [] item = new Item[N];
        for(int i=0;i<N;i++){
            item[i] = new Item(val[i],wt[i]);
        }

        //sort item based on ratio/rate
        Arrays.sort(item,(item1,item2)->Double.compare(item2.ratio,item1.ratio));
        
        double maxValue = 0;
        int remainingCapacity = capacity;
        
        for(int i=0;i<N;i++){
            
            if(remainingCapacity>0){
                if(remainingCapacity >= item[i].weight){
                    maxValue = maxValue + item[i].value;
                    remainingCapacity = remainingCapacity - item[i].weight;
                }else{
                    maxValue = maxValue + item[i].ratio * remainingCapacity;
                    remainingCapacity = 0;
                }
            }
            
            else break;
        }
        
        return maxValue;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Lemonade Change Problem (Standard denomination [5,10,20] + greedy payment service - one customer at a time)
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0,ten = 0,twenty = 0;
        int N = bills.length;
        for(int i=0;i<N;i++){
            int bill = bills[i];
            if(bill==5) five++;
            else if(bill==10){
                if(five==0) return false;
                five--;
                ten++;
            }
            else{
                if(five<1) return false;
                if(ten>=1){
                    ten--;
                    five--;
                }          
                else{
                    if(five<3) return false;
                    five = five - 3;
                } 
                twenty++;
            }
        }
        return true;
    }
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Jump Game - O(N) approach to get True/False
class Solution {
    public boolean canJump(int[] nums) {
        int maxJump = 0;
        int n =  nums.length;
        for(int i=0;i<n;i++){
            if(maxJump < i) return false;
            maxJump = Math.max(maxJump , i + nums[i]);
            if(maxJump>=n) return true;
        }
        return true;

    }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Jump Game - 2 O(N) range based approach
class Solution {
    public int jump(int[] nums) {
        //recursive to range converted
        
        int n = nums.length;
        int l=0,r=0;
        int jump=0;
        while(r<n-1){
            int farthest = 0;
            for(int i=l;i<=r;i++){
                farthest = Math.max(i + nums[i],farthest);
            }
            l = r+1;
            r = farthest;
            jump = jump + 1;
        }
        return jump;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Merge Intervals -> sort , iterate and merge
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->a[0]-b[0]);
        int start = intervals[0][0],end = intervals[0][1];
        int n = intervals.length;
        List<int []> res = new ArrayList<>();
        for(int [] i:intervals){
            if(i[0]>end){
                res.add(new int[]{start,end});
                start =i[0];
                end = i[1];
            }
            else{
                end = Math.max(end,i[1]);
            }
        }
        res.add(new int[]{start,end});
        return res.toArray(new int[0][]);
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
LRU Cache implemented using HashMap and Doubly Linked List(Coded)
class LRUCache {
    Map <Integer,Node> mpp;
    DoublyLinkList dll;
    int maxSize;
    public LRUCache(int capacity) {
        mpp = new HashMap<>();
        dll = new DoublyLinkList();
        maxSize = capacity;
    }
    
    public int get(int key) {
        if(mpp.containsKey(key)){
            Node node = mpp.get(key);
            dll.delete(node);
            dll.insertAfterHead(node);
            dll.printDLL();

            return node.value;
        }
        else{
            return -1;
        }
    }
    
    public void put(int key, int value) {
        if(mpp.containsKey(key)){
            Node node = mpp.get(key);
            node.value = value;
            dll.delete(node);
            dll.insertAfterHead(node);
            return;
        }
        if(mpp.size()==maxSize){
            Node LRU= dll.tail.prev;
            dll.delete(LRU);
            mpp.remove(LRU.key);
        }
        Node node = new Node(key,value);
        mpp.put(key,node);
        dll.insertAfterHead(node);
        dll.printDLL();
    }
}

class Node{
    int key,value;
    Node prev,next;
    public Node(int key, int value){
        this.key = key;
        this.value = value;
    }
}
class DoublyLinkList{
    Node head,tail;
    public DoublyLinkList(){
        this.head = new Node(0,0);
        this.tail= new Node(0,0);
        this.head.next = this.tail;
        this.tail.prev = this.head;
    }
    public int insertAfterHead(Node node){
        Node firstNode = this.head;
        Node nextNode = this.head.next;
        node.prev= firstNode;
        node.next= nextNode;
        firstNode.next = node;
        nextNode.prev= node;
        return node.value;
    }
    public int delete(Node node){
        Node prevNode = node.prev;
        Node nextNode = node.next;
        prevNode.next = nextNode;
        nextNode.prev = prevNode;
        return node.value;
    }
    public void printDLL(){
        Node temp = head;
        while(temp!=null){
            System.out.println(temp.key + " " +temp.value);
            temp = temp.next;
        }
    }

}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Minimum Platforms
class Solution {
    public int minPlatform(int arr[], int dep[]) {
        //  code here
        int platforms = 0;
        Arrays.sort(arr);
        Arrays.sort(dep);
        int N = arr.length;
        int i=0,j=0;
        int cnt = 0,maxCnt=0;
        while(i<N){
            if(arr[i]<=dep[j]){
                i++;
                cnt++;
            }
            else{
                j++;
                cnt--;
            }
            maxCnt = Math.max(maxCnt,cnt);
        }
        return maxCnt;
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
