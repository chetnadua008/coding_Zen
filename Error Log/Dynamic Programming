1. Climbing Stairs Problem 
  edge case, reach at N-1 Stair, return +1 (only one way to reach at Nth stair, there will not be a N+2th jump)
  
  tabulation
  class Solution {
    public int climbStairs(int n) {
        int [] dp = new int[n+1];
        for(int i=0;i<=n;i++) dp[i]=-1;
        dp[n]=+1;      //base case
        dp[n-1]=+1;
        for(int i=n-2;i>=0;i--){     //iteration
            dp[i]=dp[i+1]+dp[i+2];
        }
        return dp[0];
    }
  }
2.House Robber Problem MAX(ROB,SKIP) - non adjacent elements sub sequence maximum sum
cannot use bit manipulation to generate all subsequences - computationally expensive
houses = 100 
subsequence  = 0 to 2^100-1 (31 digit number)

dp - do not use contraint based approach
constraint based (complicated approach) - i can not rob the adjacent house
dp[i]= cash[i] + max (dp[0],dp[1],.....,dp[i-2])  state = robbing the ith house, getting cash pile from i-2th prev houses.

3. House Robber 2 -( circular 1D DP )
solve the circular constraint by forcing specific decisions:
  Case A: I MUST rob House 0 (so I cannot rob House N-1).
  Case B: I MUST rob House N-1 (so I cannot rob House 0).
Force a move destroys optimal algorithm.
Example: [5, 100, 5, 100]
Constraint relaxation
Instead of "Forcing a Rob," just Remove the Conflict:
Case A: Remove the Last House. Pass array 0 to N-2. (House 0 is available to be robbed, but not forced).
Case B: Remove the First House. Pass array 1 to N-1. (House N-1 is available to be robbed, but not forced).
Take Math.max(Case A, Case B).

4. Unique Paths Grid
tip-> go from M-1,N-1 cell to 0,0 cell for recurively calling 
so that tabulation (for loop iteration) goes from 0,0 cell to M-1,N-1 using forward easy loop :)

5. Triangle Grid -> Min Path Sum
OBSERVATION
start 0,0 
end: any cell in last row (not fixed)
usually -> N-1 th row to 0th row recursively
this case-> N-1th row have multiple starts
we take recursion from 0,0
function(i,j) returns minimum path cost from last row N-1 to cell i,j
tabulation will be done from N-1 to 0th row using backward loop

6. Handle Walls using Ternary operator
when move in grid, left when first column ,right when last column . use ternary operator to check. do not move recurively to non existing cell
if(col>0) function(row+1,col-1)
if(col<n-1) function(row+1,col+1)

7. DP On subsequence - cannot take an element of array to form target
boolean take = false;
if(target>array[index]) function(index-1,target-array[index])
cannot shrink the target when array[index]>target because the remaining target is >=0 in recurion tree
