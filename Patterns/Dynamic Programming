Dynamic Programming - solve problem by breaking into smaller overlapping sub problems

Dynamic Programming methods
1. Memoization (Top Down Approach)
2. Tabulation (Bottom Up Approach)
3. Space Optimization 

fibonacci f(n) = f(n-1) + f(n-2)
0,1,1,2,3,5......

recursive (base case + break problem + recusion tree)
f(n){
  if(n<=1) return n;
  return f(n-1)+f(n-2);
}

recursive - > memoization (save overlapping problem result of recursion tree)
1. create dp[n+1] - store sub problem results
2. if(dp[n]!=-1) return dp[n]; - do not compute again
3. return dp[n] = f(n-1) + f(n-2); - save before return
Tc O(N)
Sc O(N+N)

recursion-> tabulation (base case save + iteration to big problem)
1. declare dp[n+1]
2. initlialize base case dp[0]=0, dp[1]=1;
3. iterate for(int i=2;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];
4. return dp[n];
Tc O(N)
Sc O(N)
benifit - no recursion stack space used

tabulation-> space optimization
1. declare prev, prev2
2. prev2=0,prev=1
3. iterate for (int i=2;i<=n;i++){ curi = prev+ prev2; prev2 = prev; prev = curi} return prev;
Tc O(N)
Sc O(1)

https://takeuforward.org/data-structure/dynamic-programming-introduction/

Work with DP (Climbing stairs problem/fibonacci)
1. represent the problem as indexes
2. do all the stuff with indexes
3. 
  1.sum up all ways -> count total number of ways 
  2.min of( all ways) -> optimized way

When to use DP?
1. count total number of ways/solutions to solve a problem
2. minimum/maximum optimal solution out of all solutions to solve a problem
3. sum of solutions to solve a problem

Decision based approach in DP 
Choices and Decision taking to solve DP problem (simple easy approach)
1. climbing stairs - move 1 step or 2 steps (what gives least cost)
2. house robber - rob or not rob (what give max cash)
3. knapsack problem - take or not take item (what give max value with weight contraint)

solution
dp[i]= Math.max(cash[i] + dp[i-2], dp[i-1])
rob - keeep the cash and prev cash from i-2 houses
not rob - keep the cash from i-1 houses

2D Dynamic Programming
1. 2 state variables ex. day and task
2. greedy method (only think about now) does not work. we try all possible ways to solve the problem

Ninja Training/Paint House problem
constraint: cannot repeat the task/color from previous day
goal: maximum the points 

function returns maximum points from day to day 0, with given day and last activity
function(day,last_act){
	//base case if day = 0
	if(day==0){
		maxPoints=0;		
		for(i=0to2){
			if(i!=last){		
				maxPoints = task[0][i];
			}
		}
		return maxPoints;
	}
	maxPoints = 0;
	for(i=0 to 2){
		if(i!=last)
			points = task[day][i] + function(day-1,i);
			maxPoints = max(points,maxPoints);
		}
	}
	return maxPoints;
}

function(N-1,3) - 3 because intially we check all activities, there is no last 
