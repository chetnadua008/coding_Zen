Dynamic Programming - solve problem by breaking into smaller overlapping sub problems

Dynamic Programming methods
1. Memoization (Top Down Approach)
2. Tabulation (Bottom Up Approach)
3. Space Optimization 

fibonacci f(n) = f(n-1) + f(n-2)
0,1,1,2,3,5......

recursive (base case + break problem + recusion tree)
f(n){
  if(n<=1) return n;
  return f(n-1)+f(n-2);
}

recursive - > memoization (save overlapping problem result of recursion tree)
1. create dp[n+1] - store sub problem results
2. if(dp[n]!=-1) return dp[n]; - do not compute again
3. return dp[n] = f(n-1) + f(n-2); - save before return
Tc O(N)
Sc O(N+N)

recursion-> tabulation (base case save + iteration to big problem)
1. declare dp[n+1]
2. initlialize base case dp[0]=0, dp[1]=1;
3. iterate for(int i=2;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];
4. return dp[n];
Tc O(N)
Sc O(N)
benifit - no recursion stack space used

tabulation-> space optimization
1. declare prev, prev2
2. prev2=0,prev=1
3. iterate for (int i=2;i<=n;i++){ curi = prev+ prev2; prev2 = prev; prev = curi} return prev;
Tc O(N)
Sc O(1)

https://takeuforward.org/data-structure/dynamic-programming-introduction/

Work with DP (Climbing stairs problem/fibonacci)
1. represent the problem as indexes
2. do all the stuff with indexes
3. 
  1.sum up all ways -> count total number of ways 
  2.min of( all ways) -> optimized way

When to use DP?
1. count total number of ways/solutions to solve a problem
2. minimum/maximum optimal solution out of all solutions to solve a problem
3. sum of solutions to solve a problem

Decision based approach in DP 
Choices and Decision taking to solve DP problem (simple easy approach)
1. climbing stairs - move 1 step or 2 steps (what gives least cost)
2. house robber - rob or not rob (what give max cash)
3. knapsack problem - take or not take item (what give max value with weight contraint)

solution
dp[i]= Math.max(cash[i] + dp[i-2], dp[i-1])
rob - keeep the cash and prev cash from i-2 houses
not rob - keep the cash from i-1 houses

2D Dynamic Programming
1. 2 state variables ex. day and task
2. greedy method (only think about now) does not work. we try all possible ways to solve the problem

Ninja Training/Paint House problem
constraint: cannot repeat the task/color from previous day
goal: maximum the points 

function returns maximum points from day to day 0, with given day and last activity
function(day,last_act){
	//base case if day = 0
	if(day==0){
		maxPoints=0;		
		for(i=0to2){
			if(i!=last){		
				maxPoints = task[0][i];
			}
		}
		return maxPoints;
	}
	maxPoints = 0;
	for(i=0 to 2){
		if(i!=last)
			points = task[day][i] + function(day-1,i);
			maxPoints = max(points,maxPoints);
		}
	}
	return maxPoints;
}

function(N-1,3) - 3 because intially we check all activities, there is no last 

2D DP - MIN COST PATH in 2D Grid
dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
base case:_
Start (0,0): dp[0][0] = grid[0][0] (Cost is just the value itself).
	First Row (i=0): Can ONLY come from Left.
	dp[0][j] = grid[0][j] + dp[0][j-1]
	First Col (j=0): Can ONLY come from Up.
	dp[i][0] = grid[i][0] + dp[i-1][0]


Falling Paths Min Sum 
In Falling Path Sum, the entire bottom row is open. It's like a building with N different exit doors.
recursion will call for each starting cell of last row and then min cost out of all falling paths.
tabulation we scan last row of dp table and find min cost path

DP on subsequence
Divide an Array into two subsets, get minimum value of absolulte difference (Sum(S1)-Sum(S2))

dp[n-1][target] represent T/F if there exist a subset with sum = target in complete array (0 to N-1) (magic last row dp)
target belongs [0 (no element of subset), totSum (all elements in subset)]

iterate the last row (complete array) for target = 0 to total sum of array elements

for any dp[n-1][target] = true means there exists a subset s1 with sum = target
  we get s1 = target
          s2 = totSum-target (no need compute s2)
        MinDiff = Min(MinDiff,Abs(S2-S1))


DP - Count total number of subsets with sum == target 
the array element >=0 //count the number of subsets with sum = target
//nums[i]>=0 

function(int index,int target){
	//we dont stop when target = 0,
	//we stop when the complete array done
	if(index==0){
		//full array traverse because zeroes are spreaded
		if(target==0 && nums[0]==0) return +2;	//take + not Take zero gives two different sets
		if(target==0 || target==nums[0]) return +1;
		return 0; //target +ve. target -ve;
	}
	
	int take= 0;
	if(nums[index]<=target) take = function(index-1,target-nums[index]);
	int notTake = function(index-1,target);
	return take+notTake;
}

ex [0,0,1] 
[1],[1,0],[1,0],[1,0,0] - 4 subsets
function(N-1,target) call
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
