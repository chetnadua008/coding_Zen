Dynamic Programming - solve problem by breaking into smaller overlapping sub problems

Dynamic Programming methods
1. Memoization (Top Down Approach)
2. Tabulation (Bottom Up Approach)
3. Space Optimization 

fibonacci f(n) = f(n-1) + f(n-2)
0,1,1,2,3,5......

recursive (base case + break problem + recusion tree)
f(n){
  if(n<=1) return n;
  return f(n-1)+f(n-2);
}

recursive - > memoization (save overlapping problem result of recursion tree)
1. create dp[n+1] - store sub problem results
2. if(dp[n]!=-1) return dp[n]; - do not compute again
3. return dp[n] = f(n-1) + f(n-2); - save before return
Tc O(N)
Sc O(N+N)

recursion-> tabulation (base case save + iteration to big problem)
1. declare dp[n+1]
2. initlialize base case dp[0]=0, dp[1]=1;
3. iterate for(int i=2;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];
4. return dp[n];
Tc O(N)
Sc O(N)
benifit - no recursion stack space used

tabulation-> space optimization
1. declare prev, prev2
2. prev2=0,prev=1
3. iterate for (int i=2;i<=n;i++){ curi = prev+ prev2; prev2 = prev; prev = curi} return prev;
Tc O(N)
Sc O(1)

https://takeuforward.org/data-structure/dynamic-programming-introduction/

Work with DP (Climbing stairs problem/fibonacci)
1. represent the problem as indexes
2. do all the stuff with indexes
3. 
  1.sum up all ways -> count total number of ways 
  2.min of( all ways) -> optimized way

When to use DP?
1. count total number of ways/solutions to solve a problem
2. minimum/maximum optimal solution out of all solutions to solve a problem
3. sum of solutions to solve a problem

Decision based approach in DP 
Choices and Decision taking to solve DP problem (simple easy approach)
1. climbing stairs - move 1 step or 2 steps (what gives least cost)
2. house robber - rob or not rob (what give max cash)
3. knapsack problem - take or not take item (what give max value with weight contraint)

solution
dp[i]= Math.max(cash[i] + dp[i-2], dp[i-1])
rob - keeep the cash and prev cash from i-2 houses
not rob - keep the cash from i-1 houses

2D Dynamic Programming

1.More than one variable changes during the recursion (e.g. Index + Last_Activity OR Row + Col)
Grid Problems:Count paths from (0,0) to (N,M)" or "Min cost to cross the grid."
Constraint Problems: "Maximize profit but don't do X twice in a row" (Requires tracking last_choice).

2. The Universal State Definition:
1D DP: f(i) = Best result ending at index i.
2D DP: f(i, j) = Best result at index i given that the current state/constraint is j.

3. The Three Main Types:
  Type A: Grid Traversal (Robot/Paths)
  Logic: I can come from Top or Left.
  Formula: dp[i][j] = dp[i-1][j] + dp[i][j-1] (Count Paths) OR min(dp[i-1][j], dp[i][j-1]) (Min Path Sum).
  Space Optimization: We only need the Previous Row to build the Current Row.
  Space: O(N*M) -> O(M) (Just one row).
  
  Type B: Sequence with History (Ninjaâ€™s Training / Paint House)
  Logic: I need to choose an item today, but it depends on what I chose yesterday.
  State: dp[day][last_activity]
  for (task in tasks) {
      if (task != last_activity) {
          maxVal = max(maxVal, points[task] + f(day-1, task));
      }
  }
  Base Case: Handle the first day (Day 0) by calculating the best possible option given the incoming constraint.
  
  Type C: Subsequences (String Matching)
  Logic: Compare character s1[i] with s2[j].
  Match: 1 + f(i-1, j-1)
  No Match: max(f(i-1, j), f(i, j-1))

4. Space Optimization Rule (The "Rolling Array")
In 2D DP, you rarely need the entire matrix.
only need yesterday's data to calculate today's data.
Technique: Maintain prev[] array and curr[] array. At the end of the loop, set prev = curr.




