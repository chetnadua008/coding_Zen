Assign Cookies  
g[i] = green of children (it will not accept a cookie with size less than its greed)
s[i] = size of a cookie
goal to maximize the number of children that gets a cookie

greedy - give smallest satisfying cookie to child with minimum greed level
we do sorting of cookiesize and green then use two pointers 
if(greed[i]<=size[j]){
  i++;
  j++
}  ..child statisfied
else j++; ..cookie j is not given to any child
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Fractional KnapSack
1. Item Object -> value, weight, ration (value / weight)
2. Sort items Array in decreasing ration
3. if item weight <= bag capactity, take full
   else item weight > bag capacity, take fraction 

Item [] items = new Item[N];
for(int i=0;i<N;i++){
  items[i] = new Item(value[i],weight[i]);
}
Arrays.sort(items, (item1,item2)->Double.compare(item2,item1));
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Greedy Approach - standard denomination problem

standard denomination - greedy will always be correct
standard denomination example [1,2,5,10,20,50,100,200,500,1000,2000]
where every ith note > kth note + jth note where k<i && j<i
this is indian currency system where 
biggest coin is preffered to pay back amount (minimum number of notes would be required)

Dynamic Programming - arbitary denomination problem 
arbitary denomination example [1,4,5,6] amount = 9rs
here 6rs < 4 + 5 (9rs more value)
greedily (heavy note preferred to pay) - 6rs + 1rs + 1rs + 1rs
dynamic programming (looks all notes) - 5rs + 4rs (here 5 is not heaviest note still we end up needing two coins/notes)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Greedy Approach - valid parenthesis string with wild card *
intuition - convert the branches ( left, right, empty) to a range of count variable (min,max) representing the number of left brackets
case 1: if char == '(' min ++; max++;
case 2: if char ==')' min--;max--;
case 3: if char=='*'{
    min = Math.min(min+1,min,min-1) // basically min-1
    max = Math.max(max+1,max,max-1)//basically max+1
}
edge case:
1. if(min<0) min = 0; we cannot have branch where the number of left brackets boils to a negative value
2. if(max<0) return false; ')' does min = -1, max = -1; there is no future chance it would become valid 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
