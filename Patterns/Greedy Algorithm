Assign Cookies  
g[i] = green of children (it will not accept a cookie with size less than its greed)
s[i] = size of a cookie
goal to maximize the number of children that gets a cookie

greedy - give smallest satisfying cookie to child with minimum greed level
we do sorting of cookiesize and green then use two pointers 
if(greed[i]<=size[j]){
  i++;
  j++
}  ..child statisfied
else j++; ..cookie j is not given to any child
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Fractional KnapSack
1. Item Object -> value, weight, ration (value / weight)
2. Sort items Array in decreasing ration
3. if item weight <= bag capactity, take full
   else item weight > bag capacity, take fraction 

Item [] items = new Item[N];
for(int i=0;i<N;i++){
  items[i] = new Item(value[i],weight[i]);
}
Arrays.sort(items, (item1,item2)->Double.compare(item2,item1));
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Greedy Approach - standard denomination problem

standard denomination - greedy will always be correct
standard denomination example [1,2,5,10,20,50,100,200,500,1000,2000]
where every ith note > kth note + jth note where k<i && j<i
this is indian currency system where 
biggest coin is preffered to pay back amount (minimum number of notes would be required)

Dynamic Programming - arbitary denomination problem 
arbitary denomination example [1,4,5,6] amount = 9rs
here 6rs < 4 + 5 (9rs more value)
greedily (heavy note preferred to pay) - 6rs + 1rs + 1rs + 1rs
dynamic programming (looks all notes) - 5rs + 4rs (here 5 is not heaviest note still we end up needing two coins/notes)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Greedy Approach - valid parenthesis string with wild card *
intuition - convert the branches ( left, right, empty) to a range of count variable (min,max) representing the number of left brackets
case 1: if char == '(' min ++; max++;
case 2: if char ==')' min--;max--;
case 3: if char=='*'{
    min = Math.min(min+1,min,min-1) // basically min-1
    max = Math.max(max+1,max,max-1)//basically max+1
}
edge case:
1. if(min<0) min = 0; we cannot have branch where the number of left brackets boils to a negative value
2. if(max<0) return false; ')' does min = -1, max = -1; there is no future chance it would become valid 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Greedy - Jump Game 1
we are given an array of jumps
i am standing at index 0
i need to reach index n-1
nums[i] = maximum number of jumps i can make in forward direction
O(N) TC approach
for(int i=0 to n-1)
i am standing at index i, the maximum point where i can reach maxPoint = max(maxPoint, i + nums[i])
if at any index i, maxPoint<i means i is unreachable so return false
}
catch: as long as nums[i]>0 for all i, we can always reach n-1
fail: might not reach when there is cell with zero jumps alowed
ex
1, 1, 3, 1, 1, 0, 5 - false
1, 1, 4, 1, 1, 0, 5 - true
1, 1, 1, 1, 1, ,1 1 - always true when all positive values
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Jump Game 2
converts recursive solution to range
recursive O(N^N)
range O(N)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
